
- 화살표 함수 사용하기 : function은 호이스팅이 필요할 때만
- var 키워드 사용하지 않기

| 구분        | constructor | prototype | super | arguments |
| ----------- | ----------- | --------- | ----- | --------- |
| 일반함수    | O           | O         | X     | O         |
| 메서드      | X           | X         | O     | O         |
| 화살표 함수 | X           | X         | X     | X         |

ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 HomeObject를 갖으므로 super 키워드를 사용할 수 있다.

- Array.of : 전달된 인수를 요소로 갖는 배열 생성, Array() 생성자 함수랑 다르게 **전달된 인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열 생성**
  ```js
  Array.of(1, 2, 3) // [1, 2, 3]
  ```

- Array.from : 유사 배열 객체/이터러블 객체를 인수로 전달받아 배열로 변환하여 반환
  - 콜백 함수를 통해 값을 만들면서 요소를 채울 수 있다.
  - 콜백 함수의 반환값으로 구성된 배열 반환
  ```js
  Array.from({length:2, 0: 'a', 1:'b'}); // ['a','b']
  Array.from('hello'); // ['h','e','l','l','o']
  Array.from({length:2});  // [undefined, undefined]
  Array.from({length:2}, (item, index) => index); // [0, 1]
  ```

배열은 프로퍼티를 가질 수 있으며, 프로퍼티는 length에 영향을 주지 않는다.

배열에는 **원본 배열(배열 메서드를 호출한 배열인 배열 메서드의 구현체 내부에서 this가 가리키는 객체)을 직접 변경하는 메서드**와 **원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메서드**가 있다.

- Array.isArray : 전달된 인수가 배열이면 true, 아니면 false

- Array.prototype
  > 원본 배열 변경

  - *.indexOf(item) : 존재하는지 확인(첫번째로 검색된 인덱스 반환, 없으면 -1)
    - 배열에 NaN이 포함되어 있는지 확인할 수 없다.
      ```js
      // true가 나와야 한다.
      [NaN].indexOf(NaN) !== -1; // false
      ```

  - *.includes(item, start) : 존재하는지 확인(booelan)
    - item 요소, start 검사를 시작할 위치(-1일 경우 역순으로. length + index 연산)
    - 배열에 NaN이 포함되어 있는지 확인할 수 없다.
      ```js
      [NaN].includes(NaN); // true
      ```

  - *.push(item) : **성능이 좋지 않음**, 마지막 요소로 추가하고 length 프로퍼티 값 반환
  - *.pop() : 마지막 요소를 제거하고 요소 반환
  - *.unshift(item) : 첫번째 요소로 추가하고 length 프로퍼티 값 반환
  - *.shift() : 첫번째 요소를 제거하고 요소 반환
  - *.splice(start, deleteCount, items) : 원본 배열을 직접 변경
    - start 시작위치, deleteCount 삭제할 개수, items 이를 대체할 요소 : start <= deleteCount
  - *.reverse() : 원본 배열의 순서를 반대로 뒤집는다.
  - *.fill(item, start, end) : 인수로 전달받은 값을 배열의 처음부터 끝까지 요소로 채운다.
    - item 채울 요소, start 시작위치, end 종료할 인덱스

  > 원본 배열 변경 안됨
  - *.concat(item) : 원본 배열의 마지막 요소로 추가한 새로운 배열 반환, 인수로 전달한 값이 배열이라면 이를 해체하여 새로운 배열의 요소로 추가
    - *.concat 메서드는 스프레드 문법으로 대체 가능
  - *.slice(start, end) : 전달된 범위의 요소들을 복사하여 배열로 반환
    - start 시작위치, end 종료할 인덱스 : start <= end
  - *.join(separator) : 원본 배열의 모든 요소를 문자열로 반환하고 이를 구분자로 연결한다. 기본 구분자는 콤마(`,`)이다.
  - *.flat(depth) : 인수로 전달한 깊이만큼 배열을 평탄화
      ```js
      [1, [2, [3, [4]]]].flat(2); // [1, 2, 3, [4]]
      [1, [2, [3, [4]]]].flat().flat(); // [1, 2, 3, [4]]
      [1, [2, [3, [4]]]].flat(Infinity); // [1, 2, 3, 4]
      ```

  > 고차 함수 : 가변 데이터를 피하고 불변성을 지향하는 함수평 프로그래밍에 기반을 두고 있다. 함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 로직 내의 조건문과 반복문을 제거하여 복잡성을 해결, 변수 사용을 억제하여 상태 변경을 피한다. 즉 순수 함수를 통해 부수 효과를 최대한 억제하여 프로그램 안정성을 높이기 위함이다.

  > 원본 배열 변경
  - *.sort() : 배열의 요소 정렬. 기본적으로 오름차순으로 요소 정렬하는데 유니코드의 코드 포인트 순서를 따른다. 숫자 요소를 정렬할 때는 **정렬 순서를 정의하는 비교 함수를 인수로 전달**해야 한다.
      ```js
      const todos = [
        { id: 4, content: 'JavaScript' },
        { id: 1, content: 'HTML' },
        { id: 2, content: 'CSS' }
      ];

      // 비교 함수. 매개변수 key는 프로퍼티 키다.
      function compare(key) {
        // 프로퍼티 값이 문자열인 경우 - 산술 연산으로 비교하면 NaN이 나오므로 비교 연산을 사용한다.
        // 비교 함수는 양수/음수/0을 반환하면 되므로 - 산술 연산 대신 비교 연산을 사용할 수 있다.
        return (a, b) => (a[key] > b[key] ? 1 : (a[key] < b[key] ? -1 : 0));
      }

      // id를 기준으로 오름차순 정렬
      todos.sort(compare('id'));
      console.log(todos);
      /*
      [
        { id: 1, content: 'HTML' },
        { id: 2, content: 'CSS' },
        { id: 4, content: 'JavaScript' }
      ]
      */

      // content를 기준으로 오름차순 정렬
      todos.sort(compare('content'));
      console.log(todos);
      /*
      [
        { id: 2, content: 'CSS' },
        { id: 1, content: 'HTML' },
        { id: 4, content: 'JavaScript' }
      ]
      */
      ```
  - *.forEach() : 기본적으로 원본 배열을 변경하지 않으나 콜백 함수를 통해 원본 배열을 변경할 수 있다.
    - 해당 메서드의 반환값은 항상 undefined이다.
    - 화살표 함수로 사용하지 않는다면 두번째 인자로 this를 전달해도 된다.
    - 희소 배열의 경우 존재하지 않는 요소는 순회 대상에서 제외되며, 이는 map, filter, reduce에도 동일하다.
    - for문에 비해 성능이 좋진 않다. 그러나 가독성이 좋으므로 높은 성능이 필요하지 않다면 forEach 메서드를 권장한다.

  > 원본 배열 변경 안됨
  - *.map() : 자신을 호출한 배열의 모든 요소를 순회, 인수로 전달받은 콜백 함수를 반복 호출하며 콜백 함수의 반환값들로 구성된 새로운 배열을 반환한다.
    - map 메서드로 생성한 length 값은 호출한 배열의 length 프로퍼티와 정확히 일치한다. 즉, 1:!로 매핑한다.
  - *.filter() : 자신을 호출한 배열의 모든 요소를 순회, 인수로 전달받은 콜백 함수를 반복 호출하며 콜백 함수의 반환값이 true인 요소로만 구성된 새로운 배열 반환
  - *.reducer() : 자신을 호출한 배열의 모든 요소를 순회, 인수로 전달받은 콜백 함수를 반복 호출한다. 단, 콜백 함수의 반환 값을 다음 순회 시 콜백 함수의 첫 번째 인수로 전달하면서 콜백 함수를 호출해 하나의 결과값을 만들어 반환한다. 누적하여 반환하는 형태이다.
  - *.some() : 자신을 호출한 배열의 모든 요소를 순회, 인수로 전달받은 콜백 함수를 반복 호출한다. 콜백 함수의 반환값이 단 한번이라도 참이라면 true, 모두 거짓이면 false를 반환한다.
  - *.every() : 자신을 호출한 배열의 모든 요소를 순회, 인수로 전달받은 콜백 함수를 반복 호출한다. 콜백 함수의 반환값이 모두 참이면 true, 단 한번이라도 거짓이면 false를 반환한다.
  - *.find() : 자신을 호출한 배열의 모든 요소를 순회, 인수로 전달받은 콜백 함수를 반복 호출하며 반환값이 true인 첫 번째 요소를 반환한다. 존재하지 않으면 undefined이다.
  - *.findInder() : 자신을 호출한 배열의 모든 요소를 순회, 인수로 전달받은 콜백 함수를 반복 호출하며 반환 값이 true인 첫 번째 요소의 인덱스를 반환한다. 존재하지 않으면 -1을 반환한다.
  - *.flatMap() : map 메서드와 flat 메서드를 순차적으로 실행하는 효과가 있다.
    - 단, 1단계만 평탄화한다.
      ```js
      const arr = ['hello', 'world'];

      // flatMap은 1단계만 평탄화한다.
      arr.flatMap((str, index) => [index, [str, str.length]]);
      // -> [[0, ['hello', 5]], [1, ['world', 5]]] => [0, ['hello', 5], 1, ['world', 5]]

      // 평탄화 깊이를 지정해야 하면 flatMap 메서드를 사용하지 말고 map 메서드와 flat 메서드를 각각 호출한다.
      arr.map((str, index) => [index, [str, str.length]]).flat(2);
      // -> [[0, ['hello', 5]], [1, ['world', 5]]] => [0, 'hello', 5, 1, 'world', 5]
      ```
